<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.e12c7c9c885ec3ebdd07.css" data-identity="gatsby-global-css">/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}</style><meta name="generator" content="Gatsby 4.4.0"/><link as="script" rel="preload" href="/webpack-runtime-4d85f0db60239d65ce1c.js"/><link as="script" rel="preload" href="/framework-69325bf178eabe561408.js"/><link as="script" rel="preload" href="/app-3ff784bf8da428e12e35.js"/><link as="script" rel="preload" href="/46cc0ad690e07bdb83aca0e2e42f847dc2691093-a0f10e8d1673b14c59a5.js"/><link as="script" rel="preload" href="/component---src-pages-post-js-300889cef02639e944c7.js"/><link as="fetch" rel="preload" href="/page-data/posts/draft/os-process-2/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><title>操作系统系列之——深入进程</title><div class="sc-dkPtRN kgstGl"><div class="sc-hKwDye cUWynP"><h1>操作系统系列之——深入进程<!-- -->（草稿）</h1><h3>2020-12-29 03:09</h3></div><div id="stylemd" class="sc-bdvvtL hlRsZa"><h2>说明</h2><p>阅读本文之前，请确保你已经了解以下文章中提及到的那些知识点：</p><ul><li><a href="/posts/code/os-program/">操作系统系列之——程序</a></li><li><a href="/posts/code/os-process/">操作系统系列之——进程</a></li><li><a href="/posts/code/os-fd/">操作系统系列之——文件描述符</a></li></ul><p>前文 <a href="/posts/code/os-process/">操作系统系列之——进程</a> 中简单地在概念层面介绍了进程，更注重于理解。本文则将更侧重于进程在操作系统中的细节。</p><p>方便起见，以下的 Unix 泛指 Unix 系统和类 Unix 系统。</p><h2>进程的状态</h2><p>操作系统允许多个进程同时运行在电脑中，但进程可能很多，但 CPU 资源却是有限的，不可能所有进程每时每刻都能得到 CPU 资源进行执行，因此进程会在操作系统的调度下在不同的状态中切换，进程大致上可能的状态如下：</p><ul><li>运行态：此时进程正占用 CPU。</li><li>就绪态：进程已经处于可运行状态，但由于其他进程已经占用 CPU ，该进程暂时无法占用。</li><li>阻塞态：此时进程处于一种被动状态，他正在等待某些事件的发生，除非该事件发生，否则进程不能运行。</li></ul><p>进程状态会由于一些事件而发生转换：</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:521px">
      <a class="gatsby-resp-image-link" href="/static/8cc547ecf4a168ef093ae3a242be2e78/bb9c5/process-status.drawio.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:42.33333333333334%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACYUlEQVQoz11RXUhTYRh+d0ydWhiNkiKqi7qpC7sw0Iuu+ruJLrQLL3JQsHPmrEhD0UJXF2WUdaGEKVabYwZCllERzbXZ9Oybdc6+bZ3azNj0eJwTUmrLnU3ti08Ioheel5f34Xl4f8BgMADHccCyLNC6JGcnwF4AQghgRbiJZXHOHXSp77Az458R41gRO+r7TzPtQw1Ag2r+xXr6a0bR0NSgLd9/OL9z4E7Jp/mgKsYE8sDeTQZe2klAxiQUD/y2vOrZtbtwX15La3Pe/3q43tEBer0eyiurwGQ0FnMsq6XTBecxoKinDCvCk4Di9wcUfxAr4iCKeiqmUhHYXrSDGm0z1pqKTx4thzM1ejC31AMsjbqYDBZzqImh1rT1db81l6ykNd6PHvi8GASX4ILqmqo9p6qP60Z8TggtYOi1PtLQdZuvtOpMRkMxIXOQUAkjfksykPSMwiLiKZ9TdahsU8KHIIv49Rvy4VFGJRnmPHdJW8deLLjbdU+L4yJDuXCCgDcQhYojlRsBYIM0nQQcSwN8f/vmQIofs6QQ709NIGkZ8c+XnI5jaeEDTI04NPqz56DugklrrDVu5jgut/5yYxE1cGPlhDSbHZJkVQrHV3FIzthQ5MdBWPZ5f/2cQMR2q530mNuI7HSQFb9AsM1aCgCMuamxkGXZLSzL6pqvXtPS3sPBkdLJ+TWCpDjp6hskt7ssJBRLkvDc6hokx963pXze6ciL4fSX4WfZpXHPwjLieyf7egq+Wh8Db7Vo6Bcpui1PNX1DCDrt7nxpNns/EE0m3EIs45yYUiU5LQdn1Bt/AB9NWQSvllvtAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="进程状态图" title="进程状态图" src="/static/8cc547ecf4a168ef093ae3a242be2e78/bb9c5/process-status.drawio.png" srcSet="/static/8cc547ecf4a168ef093ae3a242be2e78/5a46d/process-status.drawio.png 300w,/static/8cc547ecf4a168ef093ae3a242be2e78/bb9c5/process-status.drawio.png 521w" sizes="(max-width: 521px) 100vw, 521px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><ol><li>进程因为等待外部事件（例如，该进程发起了 io 请求后在等待 io 完成）而被阻塞。</li><li>调度程序选择了另一个进程，该进程失去 CPU。</li><li>调度程序重新选择了这个进程。</li><li>外部事件发生（例如，io 完成）。</li></ol><h2>进程常见属性</h2><p>一个进程中会保存的许多的属性，这里取出一些后文会提到的属性：</p><ul><li>进程标识：Unix 中的每个进程都是独一无二的，他们通过进程 ID 来唯一标识，进程的 ID 也称为 <strong>PID</strong> 。</li><li>父进程标识：属性名为 <strong>PPID</strong> ，进程用它来保存父进程的 PID ，下文中有关于父进程的说明。</li><li>进程组标识：属性名为 <strong>PGID</strong> ，进程用它来保存进程组的 ID ，下文中有关于进程组的说明。</li></ul><h2>进程之间的关系</h2><p>Unix 的进程之间存在一个明显的 <strong>继承</strong> 关系，除了第一个进程外，所有的新进程都是由系统中的旧进程创建的，创建者为父进程，被创建者为子进程，因此系统中的每个进程有且仅有一个父进程，但可以拥有零到多个子进程，同时拥有同一个父进程的所有进程被成为兄弟。</p><p>在 Unix 中，大多数的进程都是 init 进程的后代，init 进程是 PID 为 1 的进程，它是系统中的第二个进程。</p><blockquote><p>TODO：找地方放这一段
内核在系统启动的最后阶段启动 init 进程，该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。
进程间的关系存放在 task_struct 中。每个 task_struct 包含一个指向其父进程 task_struct 的指针，叫做 <strong>parent</strong> 指针，还包含了一个称为 <strong>children</strong> 的子进程链表。</p></blockquote><p>在 Ubuntu14.04 下的部分进程关系如下图所示 ：</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1041px">
      <a class="gatsby-resp-image-link" href="/static/227c1369d12361e3585c9139be1b7aae/ee9b6/process-tree.drawio.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:48.33333333333333%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACh0lEQVQoz4WQW0jTcRTHv9s004f11OXJ0McI6kkhiiXUQ29BD0Y9SLpJJYjhLaJMwSyNjArtQQqdLbOm23TXf/tv/21u012ac+6iK7emzkviHEOsufjF30DoYXTgcA7n+z0fOAcAUF1dDZFIhE0jzdl12JG2WwvXjHRmZlR6C0CBaVCcw+qs77+x5Vdg1TOCZdcnxC0qTlStwpxCdjiqVb+yDIrLCktK+e9ePsv96z6KRECHFepKduDp5wTbTiGq7vowbxnEg6YmdpkT0qrxw2RAb2cHL2IVY831BhveIaT8EvwKy7IDF5wmUCNSWJRSaIee5AN8LjsPU1oeiQY5LLyrtSb/6lmALAzAq3mEzZn3yPqCVEjDTQbVSAZVF5Mh/c5uhDqZidJYnx7jEeIDIXFshw3f01GmNTE3gZ2og9fZVr8PZOs/cA/1luP93I8gIz7hN0r61j0fj32zSvY0smHEoeMXEHPKXwRMHyrIlg8kMcu5USmEsEqI0uLzqKm9jeaWBrR134eYfg38JBnOmHb4QLHgch4hBMAZ2Dx0TmWV8GBXd3tOXb+EPZvLLzrFb2isP1J7p5Z/7+G9gt6BntwJv4X3m+xyFtMx7lJ6ketb8fKQIWmwIDY3SQYpsr3XC4WiIhaUJIl9PVvOb4UQ24lievkL4IhMXrcETI2WAHPNGjQ3279ay82zTAt6gGHdUInSpihT2hXnZIxUoLQpBHLzqEDrUF2iPVQ54zM0G736CsO0vt4Zmbrpjk1VwrPk1plnmfhE0KS1Bi2r9rBVY5+3pQbo3ryxCVmdzqV+qp4afzxuk7dTbk3HuE3eRbk1fVqHSqWZVC0zPoPe6KWjvrjX4V50uP4ArR5768GAnbQAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="进程树" title="进程树" src="/static/227c1369d12361e3585c9139be1b7aae/ee9b6/process-tree.drawio.png" srcSet="/static/227c1369d12361e3585c9139be1b7aae/5a46d/process-tree.drawio.png 300w,/static/227c1369d12361e3585c9139be1b7aae/0a47e/process-tree.drawio.png 600w,/static/227c1369d12361e3585c9139be1b7aae/ee9b6/process-tree.drawio.png 1041w" sizes="(max-width: 1041px) 100vw, 1041px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><blockquote><p>你可以使用 <code>ps ajxf</code> 和 <code>pstree</code> 来查看进程的父子关系</p></blockquote><h2>进程组</h2><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:621px">
      <a class="gatsby-resp-image-link" href="/static/ea24f57c21cde77a44d209cdcc0e02a1/3075e/process-group.drawio.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:67.66666666666666%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADoUlEQVQ4y5VSW2gcZRj9ktQlaUyoJVVQfJIg+BqRgrVe0AdBUy2I4oModfetNCapqKBQH4IiglTrU73UREyK5tKNyWRnZy9zv/xz31tmb7OZmd1tYxqTmDRQ4i+7VPDBBz3wwXc4cDiH74Pywtxj2yz9xhadelW68v3AyeFTvaNnz3aHw+GuSCRy6P8O/MGzX67TKVxPxG/zP04+9dzp0w9f/GSiZ/j5lwBj3J6/8U/+b1obuwL3dY1cwX6cxNnZXx4fHDr+4OsnXgh9deULqB4UwNnJgNoQQPCSUNiywfoNAVejwN5QIbOhA7dGgVoXIL9lAQp4gPUYcXyHZ8/tMOkze3ziqIv3QqjK9CUKS6EVM9ojukw/af/avWTMhvhKqi9ZWOklrPm7aCd+N70a7yPs+RBpLx5mS8k+KrvUA1gW7sS/CWoTDWke2rcCY1dyuXethkGYvo7Nuv4T8sQLZmBgM9CyyBfPGIG2aTfMXXmNH7caetxqaXV9DqhvL3eNj77z5EOhB45U94pPKGUJi46I7ev6pwmDyhHCMqazaZpz0peWhWVMotgts6GNxVUSUyqF0Zo4wWTTTkyOYbkkKhAOhztGxkbuaaXU6tKg4oozSlWalmrMy+xq+iPeYRf5IjNKO9RrvMPOcQ59UajSz/JFZkos8dNcOXmKLzIXeIe9Jpa59yASiXS2jpPKxkFy2UHNU6bMuv6D6NLDmid/gGryrOrJ5xSPe0WtyVdRTfxc8fhnFFf8Tq4Ik/Ia+6LmyR8iV/7ZCNB4K2EncqWuwmYWCjczT/MFFnM5DmduGJ9JJTFHiATWaoi2mvqlRSaKk0biVmmn0K4cZaK4sJmZoPS4M5eYw3JZUtoJm9jvtJoaWE3tUakkXOcLXEML5BG1ppBKWcZmoM8oNeFjLsdi1VXyRgO9LZfFbaUs76u+dJ5fZRN8gcNyRZxvG2K8D0yZgrRD3q94/Jhel8fpIjkUzU8eFurUfYv2dP+COdVr74jHkpXo0WnxcjfrEwNCPT5wVf6mR1lPHrG2hXsZj+hvG/p/1jqNAIEeoBOtN7EDC+s+Om83DMhjAVJFAmK5BXAPVgE1OVhQp8HckCG/rUNUn4HM7wiqt/OgNFhoG3oH1U49UEDzlZNtw7qJNV95P38jB7qPDqUcAsj8NaBLZEequNLR2tPFlY4Wj+UXoKW3NYeAO5UxSDUWhAp9TPWkN3UfvSVWmUc0TwHNUzrSxRj8V/wFgBuwKmMyYQQAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="进程组" title="进程组" src="/static/ea24f57c21cde77a44d209cdcc0e02a1/3075e/process-group.drawio.png" srcSet="/static/ea24f57c21cde77a44d209cdcc0e02a1/5a46d/process-group.drawio.png 300w,/static/ea24f57c21cde77a44d209cdcc0e02a1/0a47e/process-group.drawio.png 600w,/static/ea24f57c21cde77a44d209cdcc0e02a1/3075e/process-group.drawio.png 621w" sizes="(max-width: 621px) 100vw, 621px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>尽管在 UNIX 中进程是被 PID 所标识的，但系统在一些场景下需要用 “组” 的形式来标识多个进程，这些进程通常共同完成某个目标，在某些事件发生时，这些进程应该能收到同样的信号。</p><p>系统为了以组的形式管理进程而引入了进程组的概念，进程组可以包含一个到多个进程，并且每个进程组也是独一无二的，有一个用来标识自己的 PGID 。</p><h3>进程组组长</h3><p>每个进程组都有一个组长，组长进程的特点是进程 ID 与 进程组 ID 相同，或者说进程组的 ID 就是由组长的 ID 决定的。</p><h3>进程离开与转移进程组</h3><p>当进程自身终止或主动转移到其他进程组时，进程则离开了当前进程组。</p><h3>进程组的生命周期</h3><p>组长可以创建一个进程组，再创建属于该组的进程。组长是否在组内与进程组是否存在无关，进程组是否存在取决于组内是否仍然存在至少一个进程。</p><p>从进程组的创建开始，到最后一个进程离开的这段时间称之为进程组的生存期。</p><h2>控制终端</h2><p>// TODO</p><h2>会话</h2><p>会话（ session ）是一个或多个进程组的集合。
// TODO 会话用来干嘛</p><p>若在终端中依次执行以下命令：</p><div class="gatsby-highlight" data-language="bash"><pre class="prism-code language-bash"><div class="token-line" style="color:#000000"><span class="token plain">proc1 </span><span class="token operator" style="color:rgb(0, 0, 0)">|</span><span class="token plain"> proc2 </span><span class="token operator" style="color:rgb(0, 0, 0)">&amp;</span><span class="token plain"></span></div><div class="token-line" style="color:#000000"><span class="token plain">proc3 </span><span class="token operator" style="color:rgb(0, 0, 0)">|</span><span class="token plain"> proc4 </span><span class="token operator" style="color:rgb(0, 0, 0)">|</span><span class="token plain"> proc5</span></div></pre></div><p>将能得到如下图所示的会话：</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:521px">
      <a class="gatsby-resp-image-link" href="/static/cfcf0db525778f1fdbef407bf4a9ce02/bb9c5/process-session.drawio.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:38.666666666666664%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACUUlEQVQozzWPX0hTURzHzzan29wVNkcUgUE9KBGGWWj03ltFkr3F1u3es3u3RkW2hdWDYib9MXspCqSnCCL/VGpzXvd/u/t3teWU/XMzN00W2ArpIcgT504PHL6Hz4/f5/x+gGQYuUWvr+WGBgn/i+dEv4lRkySpMDKMHJKkYsBsVE8OPa57wNCE6QqpooxMFQVhTddlPTEy0Ee86blXd8NwSU0ZjTWQpqsAmhfApovrzE9NlL5Nf87/9LjGh23WauT3AP71cEPZ54l+n51Z3uIDK8UPY8cRHwAIIfDb63lUcjuLP9yutS2f9y5m6M+WBKBcBmw47B25iY/ppfHRxYJ9amzh2aAMACB9//RJU8nFufPTk/Fy0JvIj75rQYtfROGmh+srcPbkutORLHudVszSsw4pGH/1UiLa56Kg9kizAtQolSaLub6tsV3pXXXqhDXB7U/6E0JxLulKzxwroBVRGC1G+/lsKBvKhbPCeuw2ZuF0TAq6u7oAPr02m/ya2aS4brlaz7DM0TOnz2pH3G/3x/JhzhGxp4R85CsXn2r9hUoV4UqwJ5DyLfAZfyJW4G9iFlripYCmaUDRNIAQ7oEQtkAIVRRFVbMsq+44d175FyH8n+xfJSWJXEqGm2OroYeBpG81mPIXhGL4DmafXBMyLBKlu7l7GYYBBoMB9PbeV5lN5qZbVpvu4oVOcRvcPL8W6w5lgpHIcigS35izbKNtsYZFGpqmNbtZeYupxbkz+QEI4b4drmFZVtd2olXTeLiBOHhoL3HqZLuWZU06XPsPWLtHvqMPIzMAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="会话" title="会话" src="/static/cfcf0db525778f1fdbef407bf4a9ce02/bb9c5/process-session.drawio.png" srcSet="/static/cfcf0db525778f1fdbef407bf4a9ce02/5a46d/process-session.drawio.png 300w,/static/cfcf0db525778f1fdbef407bf4a9ce02/bb9c5/process-session.drawio.png 521w" sizes="(max-width: 521px) 100vw, 521px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><h3>前台进程组</h3><p>会话中的所有进程组中，只有 <strong>一个</strong> 是前台进程组，tty 的输输入和信号（例如通过 ^C，^Z 产生的）会进入这个前台进程组。</p><h4>查看前台进程组</h4><p>进程可以通过函数调用 <code>tcgetpgrp(fd)</code> 来查看它所在会话的前台进程组，函数调用中的 <code>fd</code> 是该进程控制 tty 的文件描述符，若该会话不存在前台进程组，则函数随机返回大于 1 但并不代表任何 GID 的整数。</p><h4>设置前台进程组</h4><p>// TODO tty 与 会话存在关联</p><p>进程可以通过函数调用 <code>tcsetpgrp(fd, pgrp)</code> 来设置其会话组中的前台进程组，函数调用中的 <code>fd</code> 是该进程控制 tty 的文件描述符、 <code>pgrp</code> 是该进程所在会话中的一个进程组，并且要求设置时 <code>fd</code> 仍然与该进程所在会话存在关联。</p><h4>控制 tty 的文件描述符</h4><p><code>fd</code> 是控制 tty 的文件描述符，根据定义，<code>/dev/tty</code> 指控制 tty，并且完全独立于标准输入输出的重定向。打开对应名字的 <code>/dev/tty</code> 即可获得对应的控制 tty 的文件描述符</p><p>在 Ubuntu14.04 下的 <code>/dev</code> 文件夹内容如下图所示，可以看到里面有很多个 <code>tty</code> ：</p><blockquote><p><code>ctermid()</code> 函数可以获取控制终端的名字，在 POSIX 标准中，该函数返回 <code>/dev/tty</code></p></blockquote><div class="gatsby-highlight" data-language="bash"><pre class="prism-code language-bash"><div class="token-line" style="color:#000000"><span class="token plain">jabin@ubuntu-linux14:/dev$ </span><span class="token function" style="color:rgb(0, 0, 255)">ls</span><span class="token plain"> /dev</span></div><div class="token-line" style="color:#000000"><span class="token plain">autofs           loop0               ram13     sr0     tty26  tty49   ttyS13  ttyS8</span></div><div class="token-line" style="color:#000000"><span class="token plain">block            loop1               ram14     sr1     tty27  tty5    ttyS14  ttyS9</span></div><div class="token-line" style="color:#000000"><span class="token plain">bsg              loop2               ram15     stderr  tty28  tty50   ttyS15  ttyprintk</span></div><div class="token-line" style="color:#000000"><span class="token plain">btrfs-control    loop3               ram2      stdin   tty29  tty51   ttyS16  uhid</span></div><div class="token-line" style="color:#000000"><span class="token plain">bus              loop4               ram3      stdout  tty3   tty52   ttyS17  uinput</span></div><div class="token-line" style="color:#000000"><span class="token plain">cdrom            loop5               ram4      </span><span class="token function" style="color:rgb(0, 0, 255)">tty</span><span class="token plain">     tty30  tty53   ttyS18  urandom</span></div><div class="token-line" style="color:#000000"><span class="token plain">char             loop6               ram5      tty0    tty31  tty54   ttyS19  vcs</span></div><div class="token-line" style="color:#000000"><span class="token plain">console          loop7               ram6      tty1    tty32  tty55   ttyS2   vcs1</span></div><div class="token-line" style="color:#000000"><span class="token plain">core             mapper              ram7      tty10   tty33  tty56   ttyS20  vcs2</span></div><div class="token-line" style="color:#000000"><span class="token plain">cpu              mcelog              ram8      tty11   tty34  tty57   ttyS21  vcs3</span></div><div class="token-line" style="color:#000000"><span class="token plain">cpu_dma_latency  mem                 ram9      tty12   tty35  tty58   ttyS22  vcs4</span></div><div class="token-line" style="color:#000000"><span class="token plain">cuse             net                 random    tty13   tty36  tty59   ttyS23  vcs5</span></div><div class="token-line" style="color:#000000"><span class="token plain">disk             network_latency     rfkill    tty14   tty37  tty6    ttyS24  vcs6</span></div><div class="token-line" style="color:#000000"><span class="token plain">ecryptfs         network_throughput  rtc       tty15   tty38  tty60   ttyS25  vcs7</span></div><div class="token-line" style="color:#000000"><span class="token plain">fb0              null                rtc0      tty16   tty39  tty61   ttyS26  vcsa</span></div><div class="token-line" style="color:#000000"><span class="token plain">fd               port                sda       tty17   tty4   tty62   ttyS27  vcsa1</span></div><div class="token-line" style="color:#000000"><span class="token plain">full             ppp                 sda1      tty18   tty40  tty63   ttyS28  vcsa2</span></div><div class="token-line" style="color:#000000"><span class="token plain">fuse             psaux               sda2      tty19   tty41  tty7    ttyS29  vcsa3</span></div><div class="token-line" style="color:#000000"><span class="token plain">hidraw0          ptmx                sda5      tty2    tty42  tty8    ttyS3   vcsa4</span></div><div class="token-line" style="color:#000000"><span class="token plain">hidraw1          pts                 sg0       tty20   tty43  tty9    ttyS30  vcsa5</span></div><div class="token-line" style="color:#000000"><span class="token plain">hpet             ram0                sg1       tty21   tty44  ttyS0   ttyS31  vcsa6</span></div><div class="token-line" style="color:#000000"><span class="token plain">input            ram1                sg2       tty22   tty45  ttyS1   ttyS4   vcsa7</span></div><div class="token-line" style="color:#000000"><span class="token plain">kmsg             ram10               shm       tty23   tty46  ttyS10  ttyS5   vga_arbiter</span></div><div class="token-line" style="color:#000000"><span class="token plain">log              ram11               snapshot  tty24   tty47  ttyS11  ttyS6   vhost-net</span></div><div class="token-line" style="color:#000000"><span class="token plain">loop-control     ram12               snd       tty25   tty48  ttyS12  ttyS7   zero</span></div></pre></div><h3>后台进程组</h3><p>会话中所有 <strong>非前台的</strong> 进程组都是后台进程组。用户的键盘会与前台进程进行交互，因此后台进程是不应该与控制终端产生联系的。</p><p>如果一个后台进程尝试往一个控制终端读取数据，它将会收到 <code>SIGTTIN</code> 信号，通常该信号会导致该后台进程终止，但作业控制程序将会注意到这一点并且允许用户通过 <code>fg</code> 命令来挽救该进程，使该进程转为前台进程继续运行并且能够向终端读取数据。</p><p>但如果一个后台进程忽略或者 blocks 了 <code>SIGTTIN</code> 信号，又或者它的进程组是孤儿进程组，那么 <code>read()</code> 将返回 <code>EIO</code> 错误，并且不会发出信号。这意味着如果它看不到信号，那么它就会得到错误返回。实际上，这个机制是为了告诉进程现在不允许从终端读取数据。</p><p>当一个后台进程向前台进程写入数据时，它可能会收到 <code>SIGTTOU</code> 信号，是否收到该信号取决于当前的系统设置，该设置默认处于关闭状态：</p><ul><li>开启：<code>stty tostop</code></li><li>关闭：<code>stty -tostop</code></li><li>查看所有配置：<code>stty -a</code></li></ul><p>同样的，在 <code>tostop</code> 被设置的前提下，如果一个后台进程忽略或者 blocks 了 <code>SIGTTIN</code> 信号，又或者它的进程组是孤儿进程组，那么 <code>write()</code> 将返回 <code>EIO</code> 错误，并且不会发出信号。</p><h3>孤儿进程组</h3><p>进程组组长是进程的第一个成员，但它有可能会比进程组中的其他进程更快终止，然后该进程组将处于一个没有组长的状态。</p><p>当一个进程组中的每个成员的父进程都在该进程组中或都不在该会话中时，该进程组被称为孤儿进程组。特别的，会话 leader 所在的进程组一定是一个孤儿进程组。</p><p>// TODO： 整理意思</p><p>孤儿进程组命名的意义在于，或许进程组 leader 的父进程是一个作业控制 shell （在同一个会话但不同的进程组中），只要该父进程存在，它可以处理进程组成员的启动或终止，但当它终止时，也许没有人能够继续已停止的进程。因此，这些停止的进程将被发送 <code>SIGHUP</code> 信号，以此来让他们终止，除非他们主动处理或忽视该信号，然后发出 <code>SIGCONT</code> 信号来使他们继续。</p><p>注意，会话领导者的进程组已经是孤儿进程组了，因此当会话领导者死亡时不会发送任何信号。</p><p>// TODO：谜语人</p><p>再次注意，一个进程组可以用两种方式终止进程来成为孤儿进程组，一种是该进程是父进程且它不在该进程组中，另一种是它的父进程在同一个会话的其他进程组且它是该进程组中的最后一个元素。此外，进程组还可以不通过终止进程的方式成为孤儿进程，即进程组的成员被移到其他的进程组。</p><h2>参考文章</h2><ul><li><em>Linux内核设计与实现——机械工业出版社</em></li><li><em>Unix环境高级编程（第四版）</em></li><li><em>Unix操作系统设计：7.2.2 进程组</em></li><li><a href="https://en.wikipedia.org/wiki/Tty_(unix)">https://en.wikipedia.org/wiki/Tty_(unix)</a></li><li><a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B">https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B</a></li><li><a href="https://www.win.tue.nl/~aeb/linux/lk/lk-10.html">https://www.win.tue.nl/~aeb/linux/lk/lk-10.html</a></li><li><a href="https://webhostinghero.org/how-to-create-a-process-group-in-linux/">https://webhostinghero.org/how-to-create-a-process-group-in-linux/</a></li><li><a href="https://man.cx/credentials(7)">https://man.cx/credentials(7)</a></li><li><a href="https://petertc.medium.com/session-process-group-and-signal-in-linux-7fbe85c0b0c5">https://petertc.medium.com/session-process-group-and-signal-in-linux-7fbe85c0b0c5</a></li><li><a href="http://epaper.gotop.com.tw/PDFSample/AXP015900.pdf">http://epaper.gotop.com.tw/PDFSample/AXP015900.pdf</a></li><li><a href="https://docstore.mik.ua/orelly/unix/upt/ch12_07.htm">https://docstore.mik.ua/orelly/unix/upt/ch12_07.htm</a></li></ul></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/draft/os-process-2/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-71841f628f9c8d668040.js"],"app":["/app-3ff784bf8da428e12e35.js"],"component---src-pages-404-js":["/component---src-pages-404-js-46407eeca50ec9ed10bd.js"],"component---src-pages-index-js":["/component---src-pages-index-js-4ee3c921437b1bbd4a50.js"],"component---src-pages-post-js":["/component---src-pages-post-js-300889cef02639e944c7.js"],"component---src-pages-search-js":["/component---src-pages-search-js-aa816b57753a46283b1c.js"]};/*]]>*/</script><script src="/polyfill-71841f628f9c8d668040.js" nomodule=""></script><script src="/component---src-pages-post-js-300889cef02639e944c7.js" async=""></script><script src="/46cc0ad690e07bdb83aca0e2e42f847dc2691093-a0f10e8d1673b14c59a5.js" async=""></script><script src="/app-3ff784bf8da428e12e35.js" async=""></script><script src="/framework-69325bf178eabe561408.js" async=""></script><script src="/webpack-runtime-4d85f0db60239d65ce1c.js" async=""></script></body></html>